<!doctype html><html lang=zh_CN><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>函数式编程指南中文版第12章</title><link href=https://shankun.github.io/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://shankun.github.io/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://shankun.github.io/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><style>body{--primary-color:#5871a2;--primary-pale-color:#5871a210;--text-color:#3c4043;--text-pale-color:#94969f;--bg-color:#fff;--highlight-mark-color:#5f75b035;--callout-note-color:#5871a2;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460;--main-font:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:768px;--main-max-width:768px;--avatar-size:60px;--icon-size:20px;--homepage-font-size:16px;--homepage-line-height:1.75;--paragraph-font-size:16px;--paragraph-line-height:1.75;--aside-font-size:15px;--img-border-radius:0;--callout-border-radius:0;--detail-border-radius:0;--dark-mode-img-brightness:.75;--dark-mode-chart-brightness:.75;--inline-code-border-radius:2px;--inline-code-bg-color:var(--primary-pale-color);--block-code-border-radius:0;--block-code-border-color:var(--primary-color);--detail-border-color:var(--primary-color);--homepage-bg-image:url(https://shankun.github.io/img/greenBamboo.jpg)}body.dark{--primary-color:#5d77ac;--primary-pale-color:#5d77ac20;--text-color:#9197a5;--text-pale-color:#747983;--bg-color:#202124;--highlight-mark-color:#5f75b035;--callout-note-color:#5d77ac;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460}</style><link href=https://shankun.github.io/main.css rel=stylesheet><link href=https://shankun.github.io/hl-light.css id=hl rel=stylesheet><link crossorigin href=https://fastly.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV rel=stylesheet><script crossorigin defer integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 src=https://fastly.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script crossorigin defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://fastly.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}],throwOnError:false})})</script><body class=post><script>const theme = sessionStorage.getItem('theme');
    const match = window.matchMedia("(prefers-color-scheme: dark)").matches
    if ((theme && theme == 'dark') || (!theme && match)) {
      document.body.classList.add('dark');
      const hl = document.querySelector('link#hl');
      if (hl) hl.href = https://shankun.github.io/hl-dark.css;
    }</script><header class=blur><div id=header-wrapper><nav><a class=instant href=https://shankun.github.io>每一天都是离别</a><button aria-label="toggle expand" class=separator id=toggler>🚀</button><span class="wrap left fold">{</span><a class=instant href=https://shankun.github.io/posts>articles</a><span class="wrap-separator fold">,</span><a class="instant fold" href=https://shankun.github.io/projects>projects</a><span class="wrap right fold">} ;</span></nav><div id=btns><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><div id=blank></div><aside><nav><ul><li><a class=h2 href=#di-12-zhang-bian-li>第 12 章：遍历</a> <ul><li><a class=h3 href=#lei-xing-yu-lei-xing>类型与类型</a><li><a class=h3 href=#lei-xing-feng-shui>类型风水</a><li><a class=h3 href=#zuo-yong-zu-he>作用组合</a><li><a class=h3 href=#lei-xing-de-hua-er-zi>类型的华尔兹</a><li><a class=h3 href=#ding-lu>定律</a><li><a class=h3 href=#zong-jie>总结</a><li><a class=h3 href=#lian-xi>练习</a></ul></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>函数式编程指南中文版第12章</h1><div id=post-info><div id=date><span id=publish>2023-11-21</span></div><div id=tags><a class=instant href=https://shankun.github.io/tags/programming><span>#</span>programming</a><a class=instant href=https://shankun.github.io/tags/javascript><span>#</span>javascript</a></div></div><p><a rel="nofollow noreferrer" href=https://mostly-adequate.gitbook.io/mostly-adequate-guide/ch12>原文链接</a>    <a href=../mostly-adequate-guide/#mu-lu>返回目录</a><h1 id=di-12-zhang-bian-li>第 12 章：遍历<a aria-label="Anchor link for: di-12-zhang-bian-li" class=zola-anchor href=#di-12-zhang-bian-li style=visibility:hidden>#</a></h1><p>迄今为止，在我们的容器马戏团中，你曾看到我们驯服了凶猛的 <a href=https://shankun.github.io/posts/mostly-adequate-guide-ch12/ch8.md>functor</a>，让它听从我们的意志，执行任何让我们心动的操作；你曾被同时使用<a href=https://shankun.github.io/posts/mostly-adequate-guide-ch12/ch10.md>函数应用</a>来收集结果的许多危险作用的杂耍弄得晕头转向；你曾在看到容器通过 <a href=https://shankun.github.io/posts/mostly-adequate-guide-ch12/ch9.md>join</a> 凭空消失时惊讶地坐倒。在副作用杂耍中，我们看到它们经过 compose 合为一体。而最近，我们大胆地超越了自然，在你的眼前将一种类型转化为另一种 (<a href=https://shankun.github.io/posts/mostly-adequate-guide-ch12/ch11.md>natural transformations</a>)。<p>至于我们的下一个表演，我们要看一下遍历。我们将看着类型在彼此之间翱翔，就像空中飞人一样保持着我们的值不变。我们将像倾斜旋转中的手推车一样重新排列作用 (effects)。当我们的容器像变形金刚的四肢一样交织在一起时，我们可以用这个接口来进行整理。我们将见证不同的作用与不同的顺序。拿上我的长裤和滑动口哨，让我们开始吧。<h2 id=lei-xing-yu-lei-xing>类型与类型<a aria-label="Anchor link for: lei-xing-yu-lei-xing" class=zola-anchor href=#lei-xing-yu-lei-xing style=visibility:hidden>#</a></h2><p>让我们整点怪活：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> readFile :: FileName -> Task Error String</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> firstWords :: String -> String</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">firstWords</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">intercalate</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span> <span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">take</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-constant z-numeric z-decimal z-ts">3</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">split</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span> <span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> tldr :: FileName -> Task Error String</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">tldr</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">firstWords</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-variable z-other z-readwrite z-ts">readFile</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">tldr</span><span class="z-punctuation z-separator z-comma z-ts">,</span><span class="z-meta z-array z-literal z-ts"> <span class="z-meta z-brace z-square z-ts">[</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>file1<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>file2<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-square z-ts">]</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> [Task('hail the monarchy'), Task('smash the patriarchy')]</span>
</span></code></pre><p>在这里，我们读了一堆文件然后形成一个无用的 task 数组。要怎么样对其中的每一个进行 fork 操作呢？如果我们能够把类型做一些变化，得到 <code>Task Error [String]</code> 而不是 <code>[Task Error String]</code> 的话，想必是极好的。这样，我们将得到一个包含所有结果的 future value（译注：即异步任务完成后返回的值）；从异步的需求来说，这要比多个 future value （分别在各自空闲时间完成任务后再返回）要好操作得多。<p>这里有最后一个例子，展示一种棘手的情况：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> getAttribute :: String -> Node -> Maybe String</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> $ :: Selector -> IO Node</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> getControlNode :: Selector -> IO (Maybe (IO Node))</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">getControlNode</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span>
  <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">$</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span>
  <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">getAttribute</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>aria-controls<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span>
  <span class="z-variable z-other z-readwrite z-ts">$</span>
<span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>看看那些渴望在一起的 <code>IO</code> 们。如果能把他们 <code>join</code> 起来，让他们面对面地跳舞，那真是太可爱了。可惜的是，一个 <code>Maybe</code> 站在他们之间，就像舞会上的陪练。我们最好的办法是把它们的位置移到彼此旁边，这样每种类型最后都可以在一起，我们的签名可以简化为 <code>IO (Maybe Node)</code>。<h2 id=lei-xing-feng-shui>类型风水<a aria-label="Anchor link for: lei-xing-feng-shui" class=zola-anchor href=#lei-xing-feng-shui style=visibility:hidden>#</a></h2><p><code>Traversable</code> 接口由两个值得称道的函数组成：<code>sequence</code> 和 <code>traverse</code>。<p>我们用 <code>sequence</code> 重新编排编排类型：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">List</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Maybe</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-array z-literal z-ts"><span class="z-meta z-brace z-square z-ts">[</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>the facts<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-square z-ts">]</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span> <span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> [Just('the facts')]</span>
<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Task</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-new z-expr z-ts"><span class="z-keyword z-operator z-new z-ts">new</span> <span class="z-entity z-name z-type z-ts">Map</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-objectliteral z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span> <span class="z-meta z-object z-member z-ts"><span class="z-meta z-object-literal z-key z-ts">a</span></span><span class="z-meta z-object z-member z-ts"><span class="z-meta z-object-literal z-key z-ts"><span class="z-punctuation z-separator z-key-value z-ts">:</span></span> <span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Task</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-constant z-numeric z-decimal z-ts">1</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-object z-member z-ts"><span class="z-meta z-object-literal z-key z-ts">b</span></span><span class="z-meta z-object z-member z-ts"><span class="z-meta z-object-literal z-key z-ts"><span class="z-punctuation z-separator z-key-value z-ts">:</span></span> <span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Task</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-constant z-numeric z-decimal z-ts">2</span><span class="z-meta z-brace z-round z-ts">)</span> </span><span class="z-punctuation z-definition z-block z-ts">}</span></span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span> <span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Task(Map({ a: 1, b: 2 }))</span>
<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-constant z-object z-ts">IO</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-constant z-object z-ts">IO</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>buckle my shoe<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span> <span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> IO(Right('buckle my shoe'))</span>
<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span><span class="z-meta z-array z-literal z-ts"> <span class="z-meta z-brace z-square z-ts">[</span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>wing<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-square z-ts">]</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span> <span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Right(['wing'])</span>
<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Task</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">left</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>wing<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span> <span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Task(Left('wing'))</span>
</span></code></pre><p>看清楚这里发生了什么吗？嵌套类型里外翻转了过来，就像潮湿夏夜里的皮裤翻过来了一样。内部的 functor 转移到了外部，而外部的转移到了内部。不过要注意，<code>sequence</code> 对它的参数有一点挑剔。它看起来像这样子：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> sequence :: (Traversable t, Applicative f) => (a -> f a) -> t (f a) -> f (t a)</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">sequence</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">curry</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-arrow z-ts"><span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">of</span><span class="z-punctuation z-separator z-parameter z-ts">,</span> <span class="z-variable z-parameter z-ts">x</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">x</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-keyword z-operator z-expression z-of z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>我们先看第二个参数。它必须是一个持有 <em>Applicative</em> 的 <em>Traversable</em>。这听起来很严格，但是事实往往如此。这就是把 <code>t (f a)</code> 转换成了 <code>f (t a)</code>。还不够明显吗？这两种类型简直就是在背靠背。而第一个参数，它仅仅是一个拐杖，只在无类型的语言中是必要的。它提供了一个类型构造器（即 <em>of</em>）用来倒置那些不情愿被 map 的类型（比如 <code>Left</code>）——稍后会有更多介绍。<p>使用 <code>sequence</code>，我们可以像在人行道上变戏法一样精确地转移类型。但它是如何工作的呢？让我们看看一个类型，比如说 <code>Either</code>，会如何实现它：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-meta z-class z-ts"><span class="z-storage z-type z-class z-ts">class</span> <span class="z-entity z-name z-type z-class z-ts">Right</span> <span class="z-storage z-modifier z-ts">extends</span> <span class="z-entity z-other z-inherited-class z-ts">Either</span> <span class="z-punctuation z-definition z-block z-ts">{</span>
<span class="z-punctuation z-whitespace z-comment z-leading z-ts">  </span><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> ...</span>
<span class="z-meta z-method z-declaration z-ts">  <span class="z-meta z-definition z-method z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">of</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> <span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span>
    <span class="z-keyword z-control z-flow z-ts">return</span> <span class="z-meta z-function-call z-ts"><span class="z-variable z-language z-this z-ts">this</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-object z-property z-ts">$value</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
  <span class="z-punctuation z-definition z-block z-ts">}</span></span></span>
<span class="z-punctuation z-definition z-block z-ts">}</span></span>
</span></code></pre><p>没错，如果我们的 <code>$value</code> 是一个 functor （事实上它必须是一个 applicative functor），我们就可以简单地 <code>map</code> 我们的构造器来实现类型的跃迁。<p>你可能注意到，我们把 <code>of</code> 完全忽略掉了。它仅仅是为了在 <code>map</code> 不可用的情况下而被传入的，比如在 <code>Left</code> 中：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-meta z-class z-ts"><span class="z-storage z-type z-class z-ts">class</span> <span class="z-entity z-name z-type z-class z-ts">Left</span> <span class="z-storage z-modifier z-ts">extends</span> <span class="z-entity z-other z-inherited-class z-ts">Either</span> <span class="z-punctuation z-definition z-block z-ts">{</span>
<span class="z-punctuation z-whitespace z-comment z-leading z-ts">  </span><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> ...</span>
<span class="z-meta z-method z-declaration z-ts">  <span class="z-meta z-definition z-method z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">of</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> <span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span>
    <span class="z-keyword z-control z-flow z-ts">return</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-language z-this z-ts">this</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
  <span class="z-punctuation z-definition z-block z-ts">}</span></span></span>
<span class="z-punctuation z-definition z-block z-ts">}</span></span>
</span></code></pre><p>我们希望这些类型总是以相同的排列结束，所以对于像 <code>Left</code> 这样的实际上并不持有 applicative functor 的类型来说，我们有必要这么做来让它们获得一点小小的帮助。 <em>Applicative</em> 接口要求我们首先有一个 <em>Pointed Functor</em>，使得我们总是有一个 <code>of</code> 来传入。在具有类型系统的语言中，外部的类型可以通过签名被推断而不需要显式地给出。<h2 id=zuo-yong-zu-he>作用组合<a aria-label="Anchor link for: zuo-yong-zu-he" class=zola-anchor href=#zuo-yong-zu-he style=visibility:hidden>#</a></h2><p>就我们的容器而言，不同的顺序会带来不同的结果，如果我有一个 <code>[Maybe a]</code>，它是一个包含可能的值的集合 (a collection of possible values)；而如果我有一个 <code>Maybe [a]</code>，那是一个可能的包含值的集合 (a possible collection of values)。前者表示我们会宽容地保留那些"好"的值，而后者则意味着这是一个 "all or nothing" 的情况。类似地，<code>Either Error (Task Error a)</code> 可以表示一个客户端的验证，而 <code>Task Error (Either Error a)</code> 则会是一个服务端的验证。类型可以互换，为我们带来不同的作用。<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> fromPredicate :: (a -> Bool) -> a -> Either e a</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> partition :: (a -> Bool) -> [a] -> [Either e a]</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts"><span class="z-entity z-name z-function z-ts">partition</span></span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span><span class="z-meta z-arrow z-ts"> <span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">f</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">fromPredicate</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">f</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> validate :: (a -> Bool) -> [a] -> Either e [a]</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts"><span class="z-entity z-name z-function z-ts">validate</span></span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span><span class="z-meta z-arrow z-ts"> <span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">f</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">traverse</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">fromPredicate</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">f</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>这里，根据我们使用 <code>map</code> 还是 <code>traverse</code>，我们有两个不同的函数。第一个， <code>partition</code> 将会根据谓词函数给我们一个包含 <code>Left</code> 和 <code>Right</code> 的数组。这能够把宝贵的数据保留起来以供未来使用，而不是将它和洗澡水一同过滤掉。相反，<code>validate</code> 将会给我们一个包含第一个不符合谓词函数的项目的 <code>Left</code>，或者如果一切顺利的话给我们所有的包含对应元素的 <code>Right</code>。通过选择不同的类型顺序，我们得到不同的行为。<p>让我们看看 <code>List</code> 的 <code>traverse</code> 函数，来了解 <code>validate</code> 是如何形成的。<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">traverse</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-keyword z-operator z-expression z-of z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-variable z-other z-readwrite z-ts">fn</span><span class="z-meta z-brace z-round z-ts">)</span> <span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span>
  <span class="z-keyword z-control z-flow z-ts">return</span> <span class="z-meta z-function-call z-ts"><span class="z-variable z-language z-this z-ts">this</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-object z-property z-ts">$value</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">reduce</span></span><span class="z-meta z-brace z-round z-ts">(</span>
<span class="z-meta z-arrow z-ts">    <span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">f</span><span class="z-punctuation z-separator z-parameter z-ts">,</span> <span class="z-variable z-parameter z-ts">a</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">fn</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">a</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-function-call z-ts"><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-arrow z-ts"><span class="z-variable z-parameter z-ts">b</span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-arrow z-ts"><span class="z-variable z-parameter z-ts">bs</span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">bs</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-support z-function z-ts">concat</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">b</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-function-call z-ts"><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">ap</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">f</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span>
    <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-new z-expr z-ts"><span class="z-keyword z-operator z-new z-ts">new</span> <span class="z-entity z-name z-type z-ts">List</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-array z-literal z-ts"><span class="z-meta z-brace z-square z-ts">[</span><span class="z-meta z-brace z-square z-ts">]</span></span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span>
  <span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-punctuation z-definition z-block z-ts">}</span></span>
</span></code></pre><p>它仅仅是对这个列表运行了一次 <code>reduce</code>。 传入的 reduce 函数是 <code>(f, a) => fn(a).map(b => bs => bs.concat(b)).ap(f)</code>，这看起来有点儿吓人，让我们一步步看。<ol><li><p><code>reduce(..., ...)</code></p> <p>它的签名是 <code>reduce :: [a] -> (f -> a -> f) -> f -> f</code>。第一个参数事实上是由 <code>$value</code> 的点标记提供的，它是一个数组。然后我们需要一个函数，以一个 <code>f</code> (一个累计器) 和一个 a (迭代器，代表当前值) 为输入参数，返回一个新的累计器。</p><li><p><code>of(new List([]))</code></p> <p>reduce 函数的初始值是 <code>of(new List([]))</code>，在我们的例子当中则是 <code>Right([]) :: Either e [a]</code>。注意 <code>Either e [a]</code> 同时也是我们的最终返回类型。</p><li><p><code>fn::Applicative f => a -> f a</code></p> <p>如果我们把它应用到上面的例子， <code>fn</code> 实际上是 <code>fromPredicate(f) :: a -> Either e a</code></p> <blockquote><p>fn(a) :: Either e a</blockquote><li><p><code>.map(b => bs => bs.concat(b))</code></p> <p>当 <code>fn(a)</code> 是一个 <code>Right</code> 的时候，<code>Either.map</code> 将正确的值传入函数中并且返回一个包含结果的新的 <code>Right</code>。在这个例子中，函数有一个参数 (<code>b</code>)，并且返回了另一个函数 (<code>bs => bs.concat(b)</code>，其中 <code>b</code> 由于闭包的存在是在作用域内的。)。当它是一个 <code>Left</code> 时，Left 对应的值会被返回。</p> <blockquote><p>fn(a).map(b => bs => bs.concat(b)) :: Either e ([a] -> [a])</blockquote><li><p><code>ap(f)</code></p> <p><code>f</code> 在这里是一个 Applicative，所以我们可以把函数 <code>bs => bs.concat(b)</code> 应用到 <code>f</code> 中任意的值 <code>bs :: [a]</code>。幸运的是，<code>f</code> 是从我们的初始种子得到的，它有这样的类型：<code>f :: Either e [a]</code>，这也会在我们应用 <code>bs => bs.concat(b)</code> 的时候保留下来。当 <code>f</code> 是 <code>Right</code> 的时候，它将会调用 <code>bs => bs.concat(b)</code>，返回一个将元素添加到列表中的 <code>Right</code>；当它是个 <code>Left</code> 的时候，Left 对应的值会被返回。</p> <blockquote><p>fn(a).map(b => bs => bs.concat(b)).ap(f) :: Either e [a]</blockquote></ol><p>这个神奇的转换仅仅通过 <code>List.traverse</code> 中的 6 行简短的代码实现，并且通过 <code>of</code>, <code>map</code> 和 <code>ap</code> 完成，所以它将在任意的 Applicative Functor 中正常工作。这是一个很棒的例子，展示了那些抽象能够如何帮助我们写出高度通用的代码，仅仅依赖于一点点假设（而且这些假设可以通过类型系统声明和检查！）。<h2 id=lei-xing-de-hua-er-zi>类型的华尔兹<a aria-label="Anchor link for: lei-xing-de-hua-er-zi" class=zola-anchor href=#lei-xing-de-hua-er-zi style=visibility:hidden>#</a></h2><p>是时候重新回顾并且清理我们最开始的例子了。<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> readFile :: FileName -> Task Error String</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> firstWords :: String -> String</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">firstWords</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">intercalate</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span> <span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">take</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-constant z-numeric z-decimal z-ts">3</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">split</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span> <span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> tldr :: FileName -> Task Error String</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">tldr</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">firstWords</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-variable z-other z-readwrite z-ts">readFile</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">traverse</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Task</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-variable z-other z-readwrite z-ts">tldr</span><span class="z-punctuation z-separator z-comma z-ts">,</span><span class="z-meta z-array z-literal z-ts"> <span class="z-meta z-brace z-square z-ts">[</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>file1<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>file2<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-square z-ts">]</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Task(['hail the monarchy', 'smash the patriarchy']);</span>
</span></code></pre><p>使用 <code>traverse</code> 而不是 <code>map</code>，我们成功地将那些不守规矩的 <code>Task</code> 赶到了一个漂亮的、协调的结果数组中。如果你熟悉 <code>Promise.all()</code>，你会发现它们很像；只不过 <code>traverse</code> 并不是个一次性的自定义函数，它适用于任何可遍历的类型。这些数学上的 API 倾向于以一种互操作、可重用的方式捕获我们想做的大部分事情，而不必像单个类库那样为某一类型重新发明这些函数。<p>让我们清理最后一个例子来收尾。<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> getAttribute :: String -> Node -> Maybe String</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> $ :: Selector -> IO Node</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> getControlNode :: Selector -> IO (Maybe Node)</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">getControlNode</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span>
  <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">chain</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">traverse</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-constant z-object z-ts">IO</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-variable z-other z-readwrite z-ts">$</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span>
  <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">getAttribute</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>aria-controls<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span>
  <span class="z-variable z-other z-readwrite z-ts">$</span>
<span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>我们用 <code>chain(traverse(IO.of, $))</code>代替 <code>map(map($))</code>，它在映射时反转我们的类型，然后通过 chain 将两个 IO 扁平化。<h2 id=ding-lu>定律<a aria-label="Anchor link for: ding-lu" class=zola-anchor href=#ding-lu style=visibility:hidden>#</a></h2><p>好了，在你要像法官像敲槌子一样下结论关闭本章之前，还是要认识到，这些定律是很受用的法规保证。在我看来，大多数程序架构的目地是对代码加以限制来缩小可能性，最终引导我们找到正确答案。<p>一个没有定律的接口是迂回的。像其他的数学结构一样，为了我们自己的理智，我们必须暴露出属性。这和封装有类似的作用，因为它保护了数据，使我们能够用另一个遵守定律的公民来交换接口。<p>来吧，我们有一些定律要研究。<h3 id=tong-yi-lu-identity>同一律 (Identity)<a aria-label="Anchor link for: tong-yi-lu-identity" class=zola-anchor href=#tong-yi-lu-identity style=visibility:hidden>#</a></h3><pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">identity1</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Identity</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Identity</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">identity2</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-variable z-other z-object z-ts">Identity</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> test it out with Right</span>
<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">identity1</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>stuff<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Identity(Right('stuff'))</span>

<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">identity2</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>stuff<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Identity(Right('stuff'))</span>
</span></code></pre><p>这应该是很直接的。如果我们把一个 Identity 放在 functor 中，然后用 <code>sequence</code> 把它翻出来，这就和一开始就把它放在外面是一样的。我们选择 <code>Right</code> 作为小白鼠，因为它很容易验证和检查定律。一个任意的 functor 在这里是正常的，然而，在这里使用一个具体的 functor，即定律本身中的 <code>Identity</code>，可能会引起一些人的注意。请记住，一个<a href=https://shankun.github.io/posts/mostly-adequate-guide-ch12/ch5.md#%E8%8C%83%E7%95%B4%E5%AD%A6>范畴</a>是由其对象之间的变形来定义的，这些变形具有关联构成和同一性。当处理 functor 的范畴时，自然变换就是形态，而 <code>Identity</code> 就是，嗯，自身。<code>Identity</code> functor 和 <code>compose</code> 函数一样，都是很基本的定律。好了，关于 <code>Identity</code> 就先到这里，接下来我们看看 <a href=https://shankun.github.io/posts/mostly-adequate-guide-ch12/ch8.md#%E4%B8%80%E7%82%B9%E7%90%86%E8%AE%BA>Compose</a> 类型：<h3 id=zu-he-composition>组合 (Composition)<a aria-label="Anchor link for: zu-he-composition" class=zola-anchor href=#zu-he-composition style=visibility:hidden>#</a></h3><pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">comp1</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Compose</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Compose</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts"><span class="z-entity z-name z-function z-ts">comp2</span></span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span><span class="z-meta z-arrow z-ts"> <span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">Fof</span><span class="z-punctuation z-separator z-parameter z-ts">,</span> <span class="z-variable z-parameter z-ts">Gof</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span>
  </span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Compose</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">Gof</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">Fof</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Test it out with some types we have lying around</span>
<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">comp1</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">Identity</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">Right</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-array z-literal z-ts"><span class="z-meta z-brace z-square z-ts">[</span><span class="z-constant z-language z-boolean z-true z-ts">true</span><span class="z-meta z-brace z-square z-ts">]</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Compose(Right([Identity(true)]))</span>

<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">comp2</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-support z-class z-builtin z-ts">Array</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">Identity</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">Right</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-array z-literal z-ts"><span class="z-meta z-brace z-square z-ts">[</span><span class="z-constant z-language z-boolean z-true z-ts">true</span><span class="z-meta z-brace z-square z-ts">]</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Compose(Right([Identity(true)]))</span>
</span></code></pre><p>这个定律如人们所期望的那样保留了组合：如果我们交换 functor 的组合，我们不应该看到任何意外，因为组合本身就是一个 functor。我们任意地选择了 <code>true</code>、<code>Right</code>、<code>Identity</code> 和 <code>Array</code> 来测试它。像 <a rel="nofollow noreferrer" href=https://hackage.haskell.org/package/QuickCheck>quickcheck</a> 或 <a rel="nofollow noreferrer" href=http://jsverify.github.io/>jsverify</a> 这样的库可以通过模糊测试输入来帮助我们测试这个规律。<p>作为上述定律的自然结果，我们能够获得<a rel="nofollow noreferrer" href=https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf>融合遍历</a>的能力，这从性能的角度来看很不错。<h3 id=zi-ran-naturality>自然 (Naturality)<a aria-label="Anchor link for: zi-ran-naturality" class=zola-anchor href=#zi-ran-naturality style=visibility:hidden>#</a></h3><pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts"><span class="z-entity z-name z-function z-ts">natLaw1</span></span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span><span class="z-meta z-arrow z-ts"> <span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">of</span><span class="z-punctuation z-separator z-parameter z-ts">,</span> <span class="z-variable z-parameter z-ts">nt</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">nt</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-keyword z-operator z-expression z-of z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts"><span class="z-entity z-name z-function z-ts">natLaw2</span></span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span><span class="z-meta z-arrow z-ts"> <span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">of</span><span class="z-punctuation z-separator z-parameter z-ts">,</span> <span class="z-variable z-parameter z-ts">nt</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">sequence</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-keyword z-operator z-expression z-of z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">nt</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> test with a random natural transformation and our friendly Identity/Right functors.</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> maybeToEither :: Maybe a -> Either () a</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts"><span class="z-entity z-name z-function z-ts">maybeToEither</span></span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span><span class="z-meta z-arrow z-ts"> <span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">x</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">x</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">$value</span> <span class="z-keyword z-operator z-ternary z-ts">?</span> <span class="z-new z-expr z-ts"><span class="z-keyword z-operator z-new z-ts">new</span> <span class="z-entity z-name z-type z-ts">Right</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">x</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">$value</span><span class="z-meta z-brace z-round z-ts">)</span></span> <span class="z-keyword z-operator z-ternary z-ts">:</span> <span class="z-new z-expr z-ts"><span class="z-keyword z-operator z-new z-ts">new</span> <span class="z-entity z-name z-type z-ts">Left</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>

<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">natLaw1</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Maybe</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-variable z-other z-readwrite z-ts">maybeToEither</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Identity</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Maybe</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>barlow one<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Right(Identity('barlow one'))</span>

<span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">natLaw2</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-variable z-other z-readwrite z-ts">maybeToEither</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Identity</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Maybe</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>barlow one<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> Right(Identity('barlow one'))</span>
</span></code></pre><p>这和同一律有点像。如果我们先把类型翻转出来，在外部做一次 natural transformation，那将会和 map 一下 natural transformation 然后再翻转类型得到同样的结果。<p>这个定律的一个自然的结果就是：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">traverse</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-constant z-object z-ts">A</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-variable z-other z-constant z-object z-ts">A</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-meta z-brace z-round z-ts">)</span> <span class="z-keyword z-operator z-comparison z-ts">===</span> <span class="z-variable z-other z-constant z-object z-ts">A</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-variable z-other z-property z-ts">of</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>从性能的角度看，这也是极好的。<h2 id=zong-jie>总结<a aria-label="Anchor link for: zong-jie" class=zola-anchor href=#zong-jie style=visibility:hidden>#</a></h2><p><em>Traversable</em> 是一个强大的接口，能够让你像有心灵感应的室内设计师一样轻松重新编排类型。我们可以通过不同的顺序达到不同的作用，也可以熨平那些令人讨厌的无法 <code>join</code> 的类型皱纹。接下来，我们将一起欣赏函数式编程乃至于代数学本身最强大的接口之一：<a href=../mostly-adequate-guide-ch13/>Monoids</a>。<h2 id=lian-xi>练习<a aria-label="Anchor link for: lian-xi" class=zola-anchor href=#lian-xi style=visibility:hidden>#</a></h2><p>考虑下列元素：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> httpGet :: Route -> Task Error JSON</span>

<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> routes :: Map Route Route</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">routes</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-new z-expr z-ts"><span class="z-keyword z-operator z-new z-ts">new</span> <span class="z-entity z-name z-type z-ts">Map</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-objectliteral z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span> <span class="z-meta z-object z-member z-ts"><span class="z-meta z-object-literal z-key z-ts"><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>/<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span></span></span><span class="z-meta z-object z-member z-ts"><span class="z-meta z-object-literal z-key z-ts"><span class="z-punctuation z-separator z-key-value z-ts">:</span></span> <span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>/<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span></span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-object z-member z-ts"><span class="z-meta z-object-literal z-key z-ts"><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>/about<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span></span></span><span class="z-meta z-object z-member z-ts"><span class="z-meta z-object-literal z-key z-ts"><span class="z-punctuation z-separator z-key-value z-ts">:</span></span> <span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>/about<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span> </span><span class="z-punctuation z-definition z-block z-ts">}</span></span><span class="z-meta z-brace z-round z-ts">)</span></span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>使用 traversable 接口把 <code>getJsons</code> 的类型签名改成 <code>Map Route Route -> Task Error (Map Route JSON)</code><pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> getJsons :: Map Route Route -> Map Route (Task Error JSON)</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">getJsons</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">httpGet</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>我们现在定义下列校验函数：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> validate :: Player -> Either String Player</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts"><span class="z-entity z-name z-function z-ts">validate</span></span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span><span class="z-meta z-arrow z-ts"> <span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">player</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span>
  </span><span class="z-variable z-other z-object z-ts">player</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-support z-variable z-property z-dom z-ts">name</span> <span class="z-keyword z-operator z-ternary z-ts">?</span> <span class="z-meta z-function-call z-ts"><span class="z-variable z-other z-object z-ts">Either</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">of</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">player</span><span class="z-meta z-brace z-round z-ts">)</span> <span class="z-keyword z-operator z-ternary z-ts">:</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">left</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>must have name<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>使用 traversable 和 <code>validate</code> 函数，更新 <code>startGame</code> （和它的类型签名），使得只有在所有玩家是有效时才开始游戏。<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> startGame :: [Player] -> [Either Error String]</span>
<span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">const</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-constant z-ts">startGame</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">compose</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">always</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>game started!<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">validate</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>最终，我们考虑一些文件系统相关的帮助函数：<pre class="language-js z-code" data-lang=js><code class=language-js data-lang=js><span class="z-source z-ts"><span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> readfile :: String -> String -> Task Error String</span>
<span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> readdir :: String -> Task Error [String]</span>
</span></code></pre></article><div class=giscus></div><script async crossorigin data-category=Announcements data-category-id=DIC_kwDOKg3Pks4CacrE data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy data-mapping=pathname data-reactions-enabled=1 data-repo=shankun/shankun.github.io data-repo-id=R_kgDOKg3Pkg data-strict=0 data-theme=light src=https://giscus.app/client.js></script></div><footer><div class=copyright><p>© 2024 ShanKun</div><div class=credits>powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div></footer></main></div><script src=https://shankun.github.io/js/lightense.min.js></script><script src=https://shankun.github.io/js/main.js></script>