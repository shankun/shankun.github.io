+++
title = "Rust超越面向对象1——引言和封装"
date = 2023-12-12T16:31:00+08:00
draft = false
authors = ["Jimmy Hartzell"]

[taxonomies]
categories = ["学而时习之"]
tags = ["Rust"]

[extra]
lang = "zh_CN"
toc = true
copy = true
comment = true
math = false
mermaid = false
outdate_alert = false
outdate_alert_days = 120
display_tags = true
truncate_summary = false
+++

<!--more-->
# 引言
Rust不是一种面向对象语言。  
Rust可能看上去像是一种面向对象语言：类型可以关联“方法”，可以是“内在的”，也可以通过 "traits"。通常能以C++或Java风格的面向对象语法来调用方法，形如`map.insert(key, value)` 或 `foo.clone()`。就跟在面向对象编程语言中一样，这种语法涉及一个 "接收者 "参数，它被放在调用者的 . 之前，在被调用者中被称为 `self`。  
但是别搞错了，虽然 Rust 可能借用了面向对象编程语言的一些外衣、术语和语法，但它并不是面向对象编程语言。面向对象编程有三大支柱：封装、多态性和继承。其中，Rust 完全取消了继承，因此它永远不可能成为“真正的”面向对象编程语言。但即使是封装和多态性，Rust 的实现方式也与 OOP 语言不同，我们稍后将详细讨论。  
对于很多程序员来说，这种认知出乎意料之外，需要适应。我在 Reddit 上看到一些 Rust 新手询问如何按字面意思实现 OOP 设计模式，试图让“类层次结构”（如“形状”或“车辆”）与作为“Rust版本的继承”的 traits 配合使用——换句话说，他们试图解决的问题只是因为他们致力于采用 OOP 方法，并做了臆造的 OOP 示例，试图学习他们所期望的另一个版本。  
这是许多人的绊脚石。我经常在网上看到一些Rust新手和怀疑论者提到Rust “缺乏面向对象特性”，并以此作为Rust难以习惯、不适合他们的理由，甚至是Rust永远不会流行的理由。对于那些在 OOP 大潮中学习编程的人来说，当 C 和 ML 这些挺棒的语言不得不像 Objective-C 和 OCaML 一样面向对象时，对非 OOP 语言的大量炒作只会让人感觉不妥。  
这个适应过程也不容易。许多程序员都是以明确的面向对象方式学习软件设计和架构的。我看到一个又一个的问题，初级或中级 Rust 程序员想做一件面向对象的事情，并希望得到一个字面意义上的 Rust 等价物。通常情况下，这些都是 [XY 问题](https://xyproblem.info/) 的例子，他们很难回溯并以更 Rust 的方式处理问题。  
但这并不是 Rust 的错。答案仍然是我们需要适应，即使这并不容易；不仅精通多种语言，而且精通不同的编程范式，会让我们成为更好的程序员。  
而作为一种编程范式，OOP 实际上非常平庸——以至于我写了一系列博客来解释原因，以及为什么 Rust 的方法更好。  
# 面向对象编程思想
我承认，我自己也曾经喝过 OOP 的 "迷魂汤"。我还记得当时是如何向我们宣传的：它不仅是一套代码组织实践，更是一场编程革命。OOP方式被认为更直观，尤其是对非程序员而言，因为它更符合我们对自然世界的理解。  
下面是这种营销方式的典型例子，节选自流行杂志（《字节杂志》，1981 年）上发表的第一篇关于 OOP 的文章：  
> 许多不了解计算机工作原理的人认为面向对象编程的想法非常自然。相反，许多有计算机使用经验的人最初却认为面向对象系统有些奇怪。

这也很容易让人接受。当然，我们的日常生活中并没有子程序或变量之类的东西，或者说，即使有，我们也不会明确地去考虑它们！但是确实有对象，我们可以与对象交互，每个对象都有自己的功能。这已经够直观了。  
这是一门很有说服力的伪认知科学，轻研究，重说服力。这些对象可以被视为 "代理"，几乎与人无异，因此你可以利用你的社交技能来实现它，而不仅仅是分析性思维（别忘了，对象的行为与人完全不同，实际上在某种程度上更笨，仍然需要分析性思维）。或者，你也可以把对象和类看作是形式世界本身的一种近乎柏拉图式的表征，使其在哲学上更有说服力。  
哦，我是多么相信这一点，尤其是在我肆意妄为的青年时代。我个人沉浸在 OOP 和柏拉图哲学之间的联系中。我深入研究了元对象协议，以及在Smalltalk中每个类都必须有一个元类的事实。对我来说，Smalltalk代码中`Metaclass class`的概念近乎神秘，因为任何值都能以`对象`为根基，按照相同的层次结构组织起来。  
我记得在一本书中读到，OOP 风格的多态性使得 `if`-`else` 语句变得多余，因此我们应该努力最终只使用 OOP 风格的多态性。不知为什么，这不仅没有让我失望，反而让我当时很兴奋。当我了解到Smalltalk事实上就是这样做的时候，我就更加兴奋了（如果你忽略了那些优化了部分抽象的实现细节的话）： 在 Smalltalk 中，`if`-`then`-`else` 的概念是通过 `ifTrue:` 和 `ifFalse:` 以及 `ifTrue:ifFalse:` 等方法在单实例 `True` 和 `False` 类及其全局对象 `true` 和 `false` 上实现的。  
随着我成为一名更成熟的程序员，接触到C++中的面向对象，以及Haskell中的函数式编程，我的立场开始软化，然后发生了巨大的转变，现在我几乎不再是 OOP 的粉丝，尤其是当它的最佳思想在 Haskell 和 Rust 中得到更新的综合时。我意识到，这种向新程序员的大肆宣传是任何范式的典型特征。任何新的编程范式在新手眼中都比在使用不同范式的资深程序员眼中更易懂。函数式编程也是如此。Rust 也是如此。这与范式是否更好并无太大关系。  
至于`if`语句是否能完全被多态性取代，其实很容易找到一套图灵完备的primitives。你可以用多态来模拟if语句，没错。你还可以用递归来模拟while循环，或者用while循环和显式堆栈来模拟递归。你可以用while循环来模拟if语句。  
这并不能说明这些替换是更好的方法。在编程语言中，不同的功能适用于不同的情况，适度地将它们区分开来其实是件好事。  
毕竟，编程的目的是编写程序，而不是证明图灵完备性、研究哲学或者写概念诗。
# 实用性
因此，在本系列博客中，我打算以一个程序员的身份，从实用的角度来评价面向对象编程。因为我有经验，知道是什么让编程语言在认知上更易于管理或抽象。我将根据我解决实际编程问题的经验来进行评估——因为许多关于OOP抽象如何发挥作用的示例只有在真正高级的程序中才有意义，或者是在动物园中关于不同类型的形状或动物的臆造示例中才有意义，我觉得这不是一个好现象。  
与大多数介绍 OOP 的文章不同，我不会把主要精力放在比较面向对象编程语言与OOP出现之前的编程语言上。相反，我将与 Rust 进行比较，Rust 从 OOP 中汲取了许多好的思想，或许还将与 Haskell 等函数式编程语言进行比较。这些编程语言借鉴了 OOP 的一些优秀思想，但对其进行了改造，修正了其中的一些缺陷，使其超越了所谓的面向对象。  
我将根据面向对象编程的三大传统支柱：封装、多态性和继承来组织比较，第一篇文章将重点讨论封装。对于每个支柱，我将讨论 OOP 如何定义它，在 OOP 世界之外存在哪些等价物或替代物，以及这些等价物或替代物在编程的实际易用性和强大功能方面的比较。  
不过，在开始讨论之前，我想先谈谈一个颠覆了上述观点的用例：图形用户界面（GUI）。特别是在浏览器时代到来之前，编写直接在台式机（或笔记本电脑）上运行的图形用户界面程序是程序员工作的重要组成部分。在施乐公司（Xerox PARC），许多早期的 OOP 开发都是与图形用户界面的研究同步进行的。因此，图形用户界面值得特别考虑。  
例如，人们经常在其他编程语言中模拟面向对象编程。`Gtk+` 就是一个很好的例子，它用 C 语言中的一系列宏和约定来实现 OOP。这样做有很多原因，包括熟悉 OOP 设计和希望创建某种运行时多态性。但根据我的经验，这种做法在实现图形用户界面框架时最为常见。  
在本系列文章中，我们将主要关注将 OOP 应用于其他用例，但也会在适当的时候讨论图形用户界面。在这篇介绍性的文章中，我只想指出，在传统的 OOP 设计和编程语言之外，甚至在 Rust 中，图形用户界面框架显然是可行的。有时，它们通过完全不同的机制工作，比如主要由 Haskell 首创的[函数式反应编程](https://reflex-frp.org/)，我个人更喜欢这种编程方式，而不是传统的基于 OOP 的编程方式，传统的 OOP 功能对这种编程方式毫无帮助。  
现在，话不多说，让我们从实用的角度，逐一比较 OOP 和 Rust 以及其他后 OOP 编程语言。在第一篇文章的其余部分，我们将重点讨论封装。  
# 第一支柱：封装
在面向对象编程中，**封装**与**类**的概念息息相关，类是面向对象编程的基本抽象层。每个类都包含记录格式的数据布局，即每个实例包含一定数量字段的数据结构。记录类型的单个实例被称为 "对象"。每个类还包含与记录类型紧密配合的代码，这些代码被组织成**方法**。这样做的目的是，所有字段都只能从方法内部访问，这或者是基于面向对象思想的约定，或者是基于编程语言的强制规则。  
最根本的好处是可以使用**接口**，它比实现简单得多，因为实现是代码如何实际完成工作的细节，而接口则是代码如何与其他代码交互的方式，或者说是使用代码所必须了解的内容。  
当然，很多编程语言都有这样的抽象概念。任何长于十几行的程序都有太多的部分，无法同时在大脑中保存，因此所有稍微现代点的编程语言都有将程序划分为较小组件的方法，作为管理复杂性的一种方式。这样，无论是编程语言强制执行还是 "荣誉系统 "问题，接口都比实现简单。因此，从广义上讲，所有现代编程语言都有某种封装。  
封装的一种简单形式是**procedures**，也称为函数、子程序或（面向对象编程所称的）方法。现代编程语言不允许任何一行代码跳转到其他任何一行代码，而是倾向于将代码块组合到过程中，这样你就可以在不影响外部代码的情况下更改过程的内容，也可以在不影响过程的情况下更改外部代码，只要它们遵循相同的接口和协议即可。  
协议通常至少有一部分是人类层面的约定。通常情况下，并没有什么东西能阻止你把一个本应处理某些数据的存储过程变成无限循环或使程序崩溃。但其中有些规定，比如存储过程与程序其他部分的分离，以及在很多情况下，允许存储过程在调用时接受和返回的值的数量和类型，都是由编程语言强制执行的。  
例如，在存储过程中声明的变量通常是局部变量，在存储过程之外通常无法引用这些变量。输入和输出通常列在存储过程顶部的签名中。通常情况下，外部代码只能在第一行进入存储过程，而不能在中途任意一行进入。在某些编程语言（包括 Rust）中，存储过程甚至可以包含其他存储过程，而这些存储过程只能在外部存储过程中调用。  
当然，现代程序往往比仅仅几个存储过程要复杂得多。因此，现代编程语言（再次强调，这里的 "现代 "一词是以非常宽泛的方式使用的）拥有另一层封装抽象：**模块**。  
模块通常包含一组过程，有些可以从外部访问，有些则不能。在非 Duck 类型语言中，模块一般会定义一些聚合类型，同样，有些可从外部访问，有些不可访问。通常甚至可以抽象地公开这些类型，因此程序的其他部分可以访问类型的存在，但不能访问记录字段，甚至不能访问记录类型这一事实。甚至 C 语言的模块系统中也有这种能力--C++ 并没有引入这种能力，只是增加了一个额外的、正交的逐字段访问控制层次。  
从我的实用主义观点来看，基于类的封装并不是 OOP 的某种特殊见解，而是模块的一种专门形式，或者说是受到严格限制的形式。在 OOP 编程语言中，我们有一个类的概念，它是模块的一种特殊形式（有时是唯一支持的形式，有时甚至被置于一个完全不同的、更传统的模块概念之下，以造成额外的混乱）。只是，对于一个 "类 "来说，一般只能定义一种主要类型，它与模块本身共享一个名称，并且该类型的字段受到特殊保护，防止类外的代码访问。  
当然，类与模块之间还有其他区别，但这些区别与其他支柱有关，我们稍后再讨论。现在，我们只讨论 "类 "的概念，因为它与封装有关--类只是一个特殊的模块，只有一种抽象的特权类型。  
这是编写模块的一种合理方式，但它并不像面向对象编程所说的那样特别（尤其是在我们讨论了其他支柱的替代方法之后，但还是那句话，以后再说）。在某些情况下，模块并不定义任何记录类型，这在 Java 等编程语言中是很尴尬的，因为在这些语言中，无论如何你都必须定义一个空的记录类型，并且仍然要创建一个 "类"。还有一种情况是，一个模块定义了多个可公开访问的类型，这些类型紧密地纠缠在一起，在这种情况下，OOP 风格鼓励你在这些类型之间进行封装，但这与其说是一种帮助，不如说是一种阻碍。  
从根本上说，能够向其他模块隐藏记录的字段是非常重要的，这也是为什么 C 语言也支持它的原因。在 Rust 中，它甚至是对不安全特性实现安全抽象的关键，例如对于集合，原始指针在与同一记录中的其他字段结合时具有不变性。但是，这对于 OOP 来说并不新鲜，而且它也不是每种可能类型的最佳选择。  
在 Java 和 Smalltalk 中，甚至在较小程度上在 C++ 或 Python 中，坚持每类只有一种类型的封装方式意味着你会得到像`setFoo`和`getFoo`这样的模板方法，就是最好的证明。这些方法除了充当字段访问器外，什么也做不了，而从根本上说，它们是一种哑记录类型。从理论上讲，如果你想改变这些字段被设置或读取时发生的情况，这对你是有帮助的，但在实践中，它们是原始字段访问器的事实是契约的一部分。举例来说，如果这些方法不只是返回一个值，而是进行网络调用，那就会极大地损害这种简单命名方法的惊喜原则。
```
pub struct Point {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
```
要比我还是 Java 程序员时的 Java 习惯用语 "JavaBean "简单得多（Java 自那时起显然发生了变化，但这在包括 Smalltalk 在内的许多 OOP 编程语言和许多关于如何编程的书籍中都很有代表性）：
```
class Point {
    private double x;
    private double y;
    private double z;

    double getX() {
        return x;
    }

    void setX(double x) {
        this.x = x;
    }

    double getY() {
        return y;
    }

    void setY(double y) {
        this.y = y;
    }

    double getZ() {
        return z;
    }

    void setZ(double z) {
        this.z = z;
    }
}
```
此类数据类型通常不会使用 OOP 类所具有的任何其他功能，如多态性或继承性。在此类 "JavaBean "类中使用这些特性也违反了最小意外原则。对于这些记录类型来说，"类 "的概念是多余的。  
当然，Java 开发人员（或 Smalltalk，或 C#）会说，通过这些 getter 和 setter 方法间接访问字段，他们是在为类的未来做准备，以防设计发生变化（事实上，Reddit 上有人正是提出了这一点，才提醒我添加这一段的）。但我认为这种说法是虚伪的，或者至少是被误导的--它通常用于程序内部的结构，而更合理的做法是向结构的所有用户公开更改字段。此外，除了字面上的设置或获取字段（正如方法名称所暗示的那样）之外，很难想象这些方法还能做什么出人意料的事情--例如，进行网络调用对于`get`或`set`方法来说就是一个令人震惊的意外，因此至少违反了隐式契约。在我编写面向对象编程语言的过程中，我从未见过一个 getter 或 setter 除了字面意义上的获取或设置字段外，还能做其他事情的情况。  
如果代码确实发生了变化，需要 getter 或 setter 做其他事情，我宁愿修改方法的名称以反映它所做的其他事情，而不是假装这在某种程度上不是一个破坏性的变化。`fetchZFromNetwork` 或 `setAndValidateZ` 似乎比 `getZ` 或 `setZ` 更合适，因为 getZ 或 setZ 所做的不仅仅是我们认为 setter 或 getter 所做的简单字段访问。OOP 坚持认为，每种类型都应该是自己的代码抽象边界，但在应用于这些轻量级聚合类型时，这种坚持往往是荒谬的。这些类型的获取器和设置器被用来保护本不应该存在的抽象边界，因为它们只会碍事；它们还用来防止未来的实现变更，因为未来的实现变更不应该在不改变接口的情况下进行。  
简而言之，设置器和获取器是一种反模式。如果你打算创建一个除 "数据结构 "之外的抽象，在这个抽象中，验证、网络调用或其他任何超出原始字段访问的行为都是合适的，那么这些 `get` 和 `set` 的名称就是这个抽象的错误名称。  
说白了，这些反对意见也适用于属性。我反对的不是语法上的不便，而是整个概念，即用代码透明地替换字段访问是一件值得努力的好事，或者是一种值得保留的重要可能性。我希望在 Rust 中，`foo.bar = 3` 永远不会进行网络调用！如果它必须是`异步`的呢？如果我在调用一个函数，它就应该是明确的。Rust 注重明确性。  
实际上，`get` 和 `set` 函数只是用来满足面向对象意识形态约束的封装器。它们所谓的面向未来只是一种假象。如果你在抽象边界上提供了 "JavaBean"风格的类型，或带有属性的类型，那么你实际上就被锁定了，就像你提供了原始字段访问一样--你最有可能想对这些结构做出的改变将不允许移动获取器和设置器来保持兼容性。利用这种前瞻性的功能很可能完全无法实现您想要进行的更改，充其量也就是进行一次可怕的hack。  
在所有这些方面，Rust 似乎与 OOP 语言相同；从表面上看，它与类非常相似。你可以定义与给定类型相关的函数，它们甚至被称为方法！与 OOP 方法一样，这些方法在语法上允许将该类型的值（或对这些值的引用）作为第一个参数，称为特殊名称 `self`。你甚至可以将记录类型（在 Rust 中称为 `struct`）的字段标记为 public 或（默认情况下）private，鼓励使用私有字段，就像在面向对象编程语言中一样。  
根据这一支柱，Rust 似乎非常接近 OOP。对于这个支柱来说，这是一个公平的评价，也是一个有意的选择，目的是让习惯了 C++（或 Java 或 JavaScript）OOP 编程日常语法的人更容易接受 Rust 编程。  
不过，相似之处也只是皮毛而已。封装是 OOP 最不明显的支柱（毕竟，所有现代编程语言都有某种形式的封装），而 Rust 中的实现并不与类型绑定。当你在 Rust 中声明一个字段为私有时（通过不指定 `pub`），这并不意味着对其方法私有，而是对模块私有。一个模块可以提供多种类型，模块中的任何函数，无论是否是该类型的 "方法"，都可以访问该类型定义的所有字段。我们鼓励在适当的时候传递记录，而不是不鼓励，以至于即使在绑定紧密的相关代码中也要强制使用访问器。  
这是我们看到的第一个迹象，表明尽管 Rust 的语法很肤浅，但它并不是一种 OOP 编程语言。  
# 未来的文章
说到这里，我不得不暂停今天的工作。  
当然，封装并不是 OOP 风格类唯一能做的花哨事情。如果是这样，类就不会让那么多人着迷了：每个人都会明白，类不过是美化了的模块，而方法不过是美化了的过程。  
在本系列的下一篇文章中，我们将讨论与 OOP 相关的其他特性，即 OOP 的两大传统支柱——多态性和继承性，并从实用的角度对它们进行分析，看看 Rust 在这些支柱方面与 OOP 相比有何不同。  
接下来是多态性！